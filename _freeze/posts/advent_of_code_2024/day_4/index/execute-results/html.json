{
  "hash": "e7020b7c775799873647f93517fc08a6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"AOC 2024: Day 4\"\ndescription: \"Day 4 of the Advent of Code 2024: 'Mull It Over'\"\nauthor: \"Chris Brownlie\"\ndate: \"2024-12-04\"\nfrom: markdown+emoji\ncategories:\n- rstats\n- \"advent of code\"\n---\n\n\n\n\n![](/assets/advent_of_code.png){height=90% width=90% fig-align=center fig-alt=\"Logo for Advent of Code\"}\n\n## Day 4: Ceres Search\n\n\"Looks like the Chief's not here. Next!\" One of The Historians pulls out a device and pushes the only button on it. After a brief flash, you recognize the interior of the Ceres monitoring station!\n\nAs the search for the Chief continues, a small Elf who lives on the station tugs on your shirt; she'd like to know if you could help her with her word search (your puzzle input). She only has to find one word: XMAS.\n\nThis word search allows words to be horizontal, vertical, diagonal, written backwards, or even overlapping other words. It's a little unusual, though, as you don't merely need to find one instance of XMAS - you need to find all of them. Here are a few ways XMAS might appear, where irrelevant characters have been replaced with .:\n```\n..X...\n.SAMX.\n.A..A.\nXMAS.S\n.X....\n```\nThe actual word search will be full of letters instead. For example:\n```\nMMMSXXMASM\nMSAMXMSMSA\nAMXSXMAAMM\nMSAMASMSMX\nXMASAMXAMM\nXXAMMXXAMA\nSMSMSASXSS\nSAXAMASAAA\nMAMMMXMMMM\nMXMXAXMASX\n```\nIn this word search, XMAS occurs a total of 18 times; here's the same word search again, but where letters not involved in any XMAS have been replaced with .:\n```\n....XXMAS.\n.SAMXMS...\n...S..A...\n..A.A.MS.X\nXMASAMX.MM\nX.....XA.A\nS.S.S.S.SS\n.A.A.A.A.A\n..M.M.M.MM\n.X.X.XMASX\n```\nTake a look at the little Elf's word search. How many times does XMAS appear?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(purrr)\nlibrary(stringr)\nlibrary(rlang)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'rlang'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:purrr':\n\n    %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl,\n    flatten_raw, invoke, splice\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tibble)\nlibrary(tidyr)\n\ninput <- read_lines(\"input.txt\") |>\n  str_split(\"\") |>\n  map_dfr(\\(x) {\n    x |> \n      set_names(1:length(x)) |> \n      as_tibble_row()\n  })\n\n# First, some functions to help\n# From a cell coorindate in a wordsearch, move n steps in a direction and \n# get the new coordinates\nmove <- function(start, direction, n) {\n  steps <- direction * n\n  start + steps\n}\n\n# Check if a given coordinates are within the bounds of a wordsearch\nwithin_bounds <- function(location, limit_ws) {\n  if (any(dim(limit_ws)-location < 0) || \n      any(location < 1)) return(FALSE)\n  TRUE\n}\n\n# For a given row and col coordinate in a wordsearch, see how many times\n# the word XMAS can be found starting here\ncount_xmas <- function(row, col, wordsearch) {\n  # Only start with cells that contain X\n  if (wordsearch[row,col] != \"X\") return(0)\n  \n  # Look around in all directions\n  directions <- expand_grid(x = -1:1, y = -1:1)\n  \n  # For each direction from the starting cell\n  results <- map2_dbl(\n    directions$x,\n    directions$y,\n    \\(x, y, df = wordsearch) {\n      \n      # For each direction, get letters 3 steps in that direction\n      direction_word <- map_chr(\n        1:3,\n        \\(n, start = c(row, col), step = c(x, y)) {\n          # Move n steps in the current direction and get the new cell location\n          new <- move(start, step, n)\n\n          # If new location is outside wordsearch, return Z\n          if (!within_bounds(new, df)) return(\"Z\")\n          \n          # Otherwise, return the letter\n          return(df[[new[2]]][[new[1]]])\n        }\n      )\n      # If the word in that direction doesn't match XMAS, return 0\n      if (!identical(direction_word, c(\"M\", \"A\", \"S\"))) return(0)\n      \n      # Otherwise, return 1 to indicate an XMAS has been found\n      return(1)\n    }\n  )\n  # Return the total number of XMAS's which start at the current cell\n  sum(results)\n}\n\n# For each cell coordinate in a wordsearch, calculate the total number of XMAS's\ncount_all_xmas <- function(wordsearch) {\n  expand_grid(x = seq_len(NCOL(wordsearch)), \n              y = seq_len(NROW(wordsearch))) |>\n    pmap_dbl(\n      \\(x, y) count_xmas(x, y, wordsearch = wordsearch)\n    ) |>\n    sum()\n}\n\ncount_all_xmas(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2646\n```\n\n\n:::\n:::\n\n\n\n\nSuccess! :star:\n\n## Part Two\n\nThe Elf looks quizzically at you. Did you misunderstand the assignment?\n\nLooking for the instructions, you flip over the word search to find that this isn't actually an XMAS puzzle; it's an X-MAS puzzle in which you're supposed to find two MAS in the shape of an X. One way to achieve that is like this:\n```\nM.S\n.A.\nM.S\n```\nIrrelevant characters have again been replaced with . in the above diagram. Within the X, each MAS can be written forwards or backwards.\n\nHere's the same example from before, but this time all of the X-MASes have been kept instead:\n```\n.M.S......\n..A..MSMS.\n.M.S.MAA..\n..A.ASMSM.\n.M.S.M....\n..........\nS.S.S.S.S.\n.A.A.A.A..\nM.M.M.M.M.\n..........\n```\nIn this example, an X-MAS appears 9 times.\n\nFlip the word search from the instructions back over to the word search side and try again. How many times does an X-MAS appear?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# For a given row and col coordinate in a wordsearch, see if it is the centre\n# of an x-mas\ncount_x_mas <- function(row, col, wordsearch) {\n  # Only start with cells that contain A\n  if (wordsearch[row,col] != \"A\") return(0)\n  \n  # Only need to look in diagonal directions\n  directions <- expand_grid(x = c(-1, 1), y = c(-1, 1))\n  \n  # For each direction from the starting 'A' cell\n  results <- map2_chr(\n    directions$x,\n    directions$y,\n    \\(x, y, df = wordsearch) {\n      # Get the adjacent cell\n      new <- move(c(row, col), c(x, y), 1)\n      \n      # If out of bounds return Z\n      if (!within_bounds(new, df)) return(\"Z\")\n      \n      # Otherwise, return the letter\n      return(df[[new[2]]][[new[1]]])\n    }\n  )\n  \n  # Is there an X-MAS?\n  valid <- list(\n    c(\"M\", \"M\", \"S\", \"S\"),\n    c(\"S\", \"M\", \"S\", \"M\"),\n    c(\"S\", \"S\", \"M\", \"M\"),\n    c(\"M\", \"S\", \"M\", \"S\")\n  )\n  if (length(keep(valid, \\(x) identical(x, results)))) return(1)\n  return(0)\n}\n\n# For each cell coordinate in a wordsearch, see if it is the center of an x-mas\ncount_all_x_mas <- function(wordsearch) {\n  expand_grid(x = seq_len(NCOL(wordsearch)),\n              y = seq_len(NROW(wordsearch))) |>\n    pmap_dbl(\n      \\(x, y) count_x_mas(x, y, wordsearch = wordsearch)\n    ) |>\n    sum()\n}\n\ncount_all_x_mas(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2000\n```\n\n\n:::\n:::\n\n\n\n\nSuccess! :star:\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}